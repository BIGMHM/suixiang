<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb18030" />
<meta name="generator" content="Python script by program.think@gmail.com" />
<meta name="provider" content="program-think.blogspot.com" />
<link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
<title>开源点评：Protocol Buffers介绍 - 编程随想的博客</title>
</head>
<body>
<div id="main" style="width:100%;">
<h1><a href="../../index.md" title="回到首页">开源点评：Protocol Buffers介绍</a></h1>
<div class="post-info"><span class="date-header">2009-05-31</span><a href="../../tags/E7BC96E7A88B.md" class="tag">编程</a> <a href="../../tags/E7BC96E7A88B.E5BC80E6BA90E9A1B9E79BAE.md" class="tag">编程.开源项目</a> </div>
<hr>
<div class="post">
今天来介绍一下“Protocol Buffers”（以下简称protobuf）这个玩意儿。本来俺在构思“<a href="../../2009/03/producer-consumer-pattern-0-overview.md" target="_blank">生产者/消费者模式</a>”系列的下一个帖子：关于生产者和消费者之间的数据传输格式。由于里面扯到了protobuf，想想干脆单独开一个帖子算了。<!--program-think--><br /><br /><h2>★protobuf是啥玩意儿？</h2><br />　　为了照顾从没听说过的同学，照例先来扫盲一把。<br />　　首先，protobuf是一个开源项目（官方站点在“<a href="http://code.google.com/p/protobuf/" target="_blank" rel="nofollow">这里</a>”），而且是后台很硬的开源项目。网上现有的大部分（至少80%）开源项目，要么是某人单干、要么是几个闲杂人等合伙搞。而protobuf则不然，它是鼎鼎大名的Google公司开发出来，并且在Google内部久经考验的一个东东。由此可见，它的作者绝非一般闲杂人等可比。<br />　　那这个听起来牛X的东东到底有啥用处捏？简单地说，这个东东干的事儿其实和XML差不多，也就是把某种数据结构的信息，以某种格式保存起来。主要用于数据存储、传输协议格式等场合。有同学可能心理犯嘀咕了：放着好好的XML不用，干嘛重新发明轮子啊？！先别急，后面俺自然会有说道。<br />　　话说到了去年（大约是08年7月），Google突然大发慈悲，把这个好东西贡献给了开源社区。这下，像俺这种喜欢捡现成的家伙可就有福啦！貌似喜欢捡现成的家伙还蛮多滴，再加上Google的号召力，开源后不到一年，protobuf的人气就已经很旺了。所以俺为了与时俱进，就单独开个帖子来忽悠一把。<br /><br /><h2>★protobuf有啥特色？</h2><br />　　扫盲完了之后，就该聊一下技术方面的话题了。由于这玩意儿发布的时间较短（未满周岁），所以俺接触的时间也不长。今天在此是先学现卖，列位看官多多包涵 <b>:-)</b><br /><br /><h3>◇性能好/效率高</h3><br />　　现在，俺就来说说Google公司为啥放着好端端的XML不用，非要另起炉灶，重新造轮子。一个根本的原因是XML性能不够好。<br />　　先说时间开销：XML格式化（序列化）的开销倒还好；但是XML解析（反序列化）的开销就不敢恭维啦。俺之前经常碰到一些时间性能很敏感的场合，由于不堪忍受XML解析的速度，弃之如敝履。<br />　　再来看空间开销：熟悉XML语法的同学应该知道，XML格式为了有较好的可读性，引入了一些冗余的文本信息。所以空间开销也不是太好（不过这点缺点，俺不常碰到）。<br />　　由于Google公司赖以吹嘘的就是它的海量数据和海量处理能力。对于几十万、上百万机器的集群，动不动就是PB级的数据量，哪怕性能稍微提高0.1%也是相当可观滴。所以Google自然无法容忍XML在性能上的明显缺点。再加上Google从来就不缺造轮子的牛人，所以protobuf也就应运而生了。<br />　　Google对于性能的偏执，那可是出了名的。所以，俺对于Google搞出来protobuf是非常滴放心，性能上不敢说是最好，但肯定不会太差。<br /><br /><h3>◇代码生成机制</h3><br />　　除了性能好，代码生成机制是主要吸引俺的地方。为了说明这个代码生成机制，俺举个例子。<br />　　比如有个电子商务的系统（假设用C++实现），其中的模块A需要发送大量的订单信息给模块B，通讯的方式使用socket。<br />假设订单包括如下属性：<br />－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br />　　时间：time（用整数表示）<br />　　客户id：userid（用整数表示）<br />　　交易金额：price（用浮点数表示）<br />　　交易的描述：desc（用字符串表示）<br />－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br />　　如果使用protobuf实现，首先要写一个proto文件（不妨叫Order.proto），在该文件中添加一个名为"Order"的message结构，用来描述通讯协议中的结构化数据。该文件的内容大致如下：<br /><pre><font face="Courier New"><br />message Order<br />{<br />  required int32 time = 1;<br />  required int32 userid = 2;<br />  required float price = 3;<br />  optional string desc = 4;<br />}<br /></font></pre><br />　　然后，使用protobuf内置的编译器<b>编译</b>该proto。由于本例子的模块是C++，你可以通过protobuf编译器的命令行参数（看“<a href="http://code.google.com/apis/protocolbuffers/docs/proto.html#generating" target="_blank" rel="nofollow">这里</a>”），指定它生成C++语言的“订单包装类”。（一般来说，一个message结构会生成一个包装类）<br />　　然后你使用类似下面的代码来序列化/解析该订单包装类：<br /><pre><font face="Courier New"><br />// 发送方<br />Order order;<br />order.set_time(XXXX);<br />order.set_userid(123);<br />order.set_price(100.0f);<br />order.set_desc("a test order");<br /><br />string sOrder;<br />order.SerailzeToString(&amp;sOrder);<br />// 然后调用某种socket的通讯库把序列化之后的字符串发送出去<br />// ......<br /><br />－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br /><br />// 接收方<br />string sOrder;<br />// 先通过网络通讯库接收到数据，存放到某字符串sOrder<br />// ......<br /><br />Order order;<br />if(order.ParseFromString(sOrder))  // 解析该字符串<br />{<br />  cout &lt;&lt; "userid:" &lt;&lt; order.userid() &lt;&lt; endl<br />          &lt;&lt; "desc:" &lt;&lt; order.desc() &lt;&lt; endl;<br />}<br />else<br />{<br />  cerr &lt;&lt; "parse error!" &lt;&lt; endl;<br />}<br /></font></pre><br />　　有了这种代码生成机制，开发人员再也不用吭哧吭哧地编写那些协议解析的代码了（干这种活是典型的吃力不讨好）。<br />　　万一将来需求发生变更，要求给订单再增加一个“状态”的属性，那只需要在Order.proto文件中增加一行代码。对于发送方（模块A），只要增加一行设置状态的代码；对于接收方（模块B）只要增加一行读取状态的代码。哇塞，简直太轻松了！<br />　　另外，如果通讯双方使用不同的编程语言来实现，使用这种机制可以有效确保两边的模块对于协议的处理是一致的。<br />　　顺便跑题一下。<br />　　从某种意义上讲，可以把proto文件看成是描述通讯协议的规格说明书（或者叫接口规范）。这种伎俩其实老早就有了，搞过微软的COM编程或者接触过CORBA的同学，应该都能从中看到IDL（详细解释看“<a href="http://en.wikipedia.org/wiki/IDL_specification_language" target="_blank" rel="nofollow">这里</a>”）的影子。它们的思想是相通滴。<br /><br /><h3>◇支持“向后兼容”和“向前兼容”</h3><br />　　还是拿刚才的例子来说事儿。为了叙述方便，俺把增加了“状态”属性的订单协议成为“新版本”；之前的叫“老版本”。<br />　　所谓的“向后兼容”（backward compatible），就是说，当模块B升级了之后，它能够正确识别模块A发出的老版本的协议。由于老版本没有“状态”这个属性，在扩充协议时，可以考虑把“状态”属性设置成<b>非必填</b>的，或者给“状态”属性设置一个缺省值（如何设置缺省值，参见“<a href="http://code.google.com/p/protobuf-c/wiki/Default_Values" target="_blank" rel="nofollow">这里</a>”）。<br />　　所谓的“向前兼容”（forward compatible），就是说，当模块A升级了之后，模块B能够正常识别模块A发出的新版本的协议。这时候，新增加的“状态”属性会被忽略。<br />　　“向后兼容”和“向前兼容”有啥用捏？俺举个例子：当你维护一个很庞大的分布式系统时，由于你无法<b>同时</b>升级<b>所有</b>模块，为了保证在升级过程中，整个系统能够尽可能不受影响，就需要尽量保证通讯协议的“向后兼容”或“向前兼容”。<br /><br /><h3>◇支持多种编程语言</h3><br />　　俺开博以来点评的几个开源项目（比如“<a href="../../2009/03/opensource-review-sqlite-database.md" target="_blank">Sqlite</a>”、“<a href="../../2009/03/opensource-review-curl-library.md" target="_blank">cURL</a>”），都是支持<b>很多种</b>编程语言滴，这次的protobuf也不例外。在Google官方发布的源代码中包含了C++、Java、Python三种语言（正好也是俺最常用的三种，真爽）。如果你平时用的就是这三种语言之一，那就好办了。<br />　　假如你想把protobuf用于其它语言，咋办捏？由于Google一呼百应的号召力，开源社区对protobuf响应踊跃，近期冒出很多其它编程语言的版本（比如ActionScript、C#、Lisp、Erlang、Perl、PHP、Ruby等），有些语言还同时搞出了多个开源的项目。具体细节可以参见“<a href="http://code.google.com/p/protobuf/wiki/OtherLanguages" target="_blank" rel="nofollow">这里</a>”。<br />　　不过俺有义务提醒一下在座的各位同学。如果你考虑把protobuf用于上述这些语言，一定认真评估对应的开源库。因为这些开源库不是Google官方提供的、而且出来的时间还不长。所以，它们的质量、性能等方面可能还有欠缺。<br /><br /><h2>★protobuf有啥缺陷？</h2><br />　　前几天刚刚在“<a href="../../2009/05/halo-effect.md">光环效应</a>”的帖子里强调了“要同时评估优点和缺点”。所以俺最后再来批判一下这玩意儿的缺点。<br /><br /><h3>◇应用不够广</h3><br />　　由于protobuf刚公布没多久，相比XML而言，protobuf还属于初出茅庐。因此，在知名度、应用广度等方面都远不如XML。由于这个原因，假如你设计的系统需要提供若干对外的接口给第三方系统调用，俺奉劝你暂时不要考虑protobuf格式。<br /><br /><h3>◇二进制格式导致可读性差</h3><br />　　为了提高性能，protobuf采用了二进制格式进行编码。这直接导致了可读性差的问题（严格地说，是没有可读性）。虽然protobuf提供了TextFormat这个工具类（文档在“<a href="http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.text_format.md" target="_blank" rel="nofollow">这里</a>”），但终究无法彻底解决此问题。<br />　　可读性差的危害，俺再来举个例子。比如通讯双方如果出现问题，极易导致扯皮（都不承认自己有问题，都说是对方的错）。俺对付扯皮的一个简单方法就是直接抓包并dump成log，能比较容易地看出错误在哪一方。但是protobuf的二进制格式，导致你抓包并直接dump出来的log难以看懂。<br /><br /><h3>◇缺乏自描述</h3><br />　　一般来说，XML是自描述的，而protobuf格式则不是。给你一段二进制格式的协议内容，如果不配合相应的proto文件，那简直就像天书一般。<br />　　由于“缺乏自描述”，再加上“二进制格式导致可读性差”。所以在配置文件方面，protobuf是肯定无法取代XML的地位滴。<br /><br /><h2>★为什么俺会选用protobuf？</h2><br />　　俺自从前段时间接触了protobuf之后，就着手把俺负责的产品中的<b>部分</b>数据传输协议替换成protobuf。可能有同学会问，和protobuf类似的东东也有不少，为啥独独相中protobuf捏？由于今天写的篇幅已经蛮长了，俺卖个关子，把这个话题留到“生产者/消费者模式[5]：如何选择传输协议及格式？”。俺会在后续的这个帖子里对比各种五花八门的协议格式，并谈谈俺的浅见。<br /><br /><b>俺博客上，和本文相关的帖子（需翻墙）</b>：<br /><a href="../../2011/08/opensource-review-zeromq.md">开源点评：ZeroMQ简介</a><br /><a href="../../2009/03/opensource-review-curl-library.md">开源点评：cURL――优秀的应用层网络协议库</a><div class="blogger-post-footer">
</div>
<hr>
<div class="copyright">
<h4>版权声明</h4>
本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者<a href="mailto:program.think@gmail.com">编程随想</a>和本文原始网址：<br>
<a href="/2009/05/opensource-review-protocol-buffers.md">2009/05/opensource-review-protocol-buffers.html</a>
</div>
</div>
</body>
</html>
