<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb18030" />
<meta name="generator" content="Python script by program.think@gmail.com" />
<meta name="provider" content="program-think.blogspot.com" />
<link type="text/css" rel="stylesheet" href="../../css/program-think.css" />
<title>如何保护隐私[6]：如何防范“浏览器指纹”？ - 编程随想的博客</title>
</head>
<body>
<div id="main" style="width:100%;">
<h1><a href="../../index.md" title="回到首页">如何保护隐私[6]：如何防范“浏览器指纹”？</a></h1>
<div class="post-info"><span class="date-header">2014-01-22</span><a href="../../tags/IT.md" class="tag">IT</a> <a href="../../tags/IT.E4BFA1E681AFE5AE89E585A8.md" class="tag">IT.信息安全</a> </div>
<hr>
<div class="post">
&#12288;&#12288;前一篇介绍了“<a href="../../2014/01/privacy-protection-5.md">浏览器指纹的基本概念</a>”今天这篇分享一些防范的技巧。<a name='more'></a><!--program-think--><br /><br /><h2>★防范“指纹”的一般性原则？</h2><br />&#12288;&#12288;不管是哪一种特征，要想成为“指纹”至少要具备两个条件：“唯一性”和“稳定性”。比如人类手指的纹路就同时具有“唯一性”和“稳定性”――任意两个人的纹路都不同，而且每个人的纹路终生不变。所以，要对付“指纹识别”，咱们就必须反其道而行――破坏“唯一性”和“稳定性”。对浏览器而言，做到这两点并不难。且听俺细细道来。<br /><br /><h2>★浏览器指纹的关键性信息</h2><br />&#12288;&#12288;<a href="../../2014/01/privacy-protection-5.md">前一篇博文</a>已经给大伙儿介绍了 EFF 的浏览器指纹测试工具（链接在“<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E5%89%8D%E5%93%A8%E5%9F%BA%E9%87%91%E4%BC%9A" target="_blank" rel="nofollow">这里</a>”）。通过这个工具可以明显看出，User Agent 的信息量最大，至少占据一半以上的信息量。换句话说，其它所有特征的信息量加起来都没有 User Agent 大。而且除了 User Agent，其它特征的信息量都比较小。这说明啥捏？<br />&#12288;&#12288;请大伙儿换位思考一下：如果某个网站想要利用浏览器指纹进行用户身份定位，User Agent 是必不可少的一项。缺少这一项，定位的精度会大打折扣。所以，User Agent 是浏览器指纹的关键性信息。<br />&#12288;&#12288;俺已经在博客中多次唠叨了“<a href="../../2009/02/80-20-principle-0-overview.md">二八原理</a>”，浏览器指纹中的 User Agent 就是这关键性的“20%”。下面俺来介绍：如何破坏 User Agent 的“唯一性”和“稳定性”。<br /><br /><h2>★“多浏览器”方案</h2><br />&#12288;&#12288;这个方案最简单，也最容易想到。一看这个小标题，估计大部分读者都猜到俺想喷啥口水。<br />&#12288;&#12288;如果你同时具有两个不同的浏览器（比如一个 Firefox 一个 Chrome），那么这两个浏览器必然具有不同的 User Agent。如果某个网站收集了浏览器指纹，而你又想在这个网站注册两个不同的马甲，那么你就可以用“多浏览器方案”――分别用不同的浏览器注册不同的马甲。<br />&#12288;&#12288;<b>本方案的优点</b><br />&#12288;&#12288;操作很简单，会装浏览器的同学都玩。<br />&#12288;&#12288;<b>本方案的缺点</b><br />&#12288;&#12288;浏览器的种类毕竟有限（知名且靠谱的浏览器，一只手都能数过来）。万一你想注册十多个马甲，用这个方案就显得傻B了。<br /><br /><h2>★“多实例”方案</h2><br />&#12288;&#12288;为了解决“多浏览器方案”的局限性，自然会想到“多实例”这个方案。此招数俺曾经在《<a href="../../2010/06/howto-prevent-hacker-attack-0.md">如何防止黑客入侵</a>》系列博文中介绍过。<br />&#12288;&#12288;在主流的三大浏览器中，Firefox 和 Chrome 支持“多实例”，IE 不支持。所以那些喜欢 IE 的同学就没法用这招了。<br />&#12288;&#12288;关于 Firefox 和 Chrome 如何配置多实例，请看俺之前的博文（<a href="../../2012/09/howto-prevent-hacker-attack-6.html#multi_profile">这里</a>）。对于用 Chrome 的同学，俺再次罗嗦一下：Chrome 同时提供“多实例”（洋文叫“Multiple Profiles”）和“多用户”（洋文叫“Multiple Accounts”）两种功能，这两者是完全不同滴。它的“多用户”依然在同一个“实例”中。<br />&#12288;&#12288;<b>配置完“多实例”之后，一定要记得修改每一个实例的 User Agent，并确保两两不同。</b>至于如何修改 User Agent 请参见“<a href="../../2013/07/privacy-protection-4.html#user_agent">这篇博文</a>”――里面提供了三大主流浏览器的修改方法。<br />&#12288;&#12288;<b>本方案的优点</b><br />&#12288;&#12288;浏览器的实例可以配置任意多个（只要你有耐心，硬盘够大，配几百几千都可以）。<br />&#12288;&#12288;<b>本方案的缺点</b><br />&#12288;&#12288;某些浏览器（比如 IE）不支持多实例。<br /><br /><h2>★“多虚拟机”方案</h2><br />&#12288;&#12288;要对付 User Agent 的指纹，前面两招基本够用了。但某些同学可能有特殊需求，或者安全要求比较高，所以俺顺便介绍第三种方法。<br />&#12288;&#12288;第三种方法就是利用虚拟机软件安装不同的虚拟系统，然后在每个虚拟系统中安装浏览器。没用过虚拟化软件的同学，先看俺之前的扫盲教程（在“<a href="../../2012/10/system-vm-0.md">这里</a>”）。再次罗嗦：如果你在不同的虚拟机中安装相同的浏览器，要记得修改每个虚拟机中浏览器的 User Agent。<br />&#12288;&#12288;<b>本方案的优点</b><br />&#12288;&#12288;优点1：前面说了，某些浏览器不支持多实例。万一你偏偏喜欢这种浏览器，就可以考虑用“多虚拟机”的方案。<br />&#12288;&#12288;优点2：因为屏幕分辨率、系统时区也都是指纹特征。所以在虚拟系统中，你还可以调整屏幕分辨率和时区（使之不同于你真实系统的分辨率和时区）。<br />&#12288;&#12288;<b>本方案的缺点</b><br />&#12288;&#12288;缺点1：你需要额外安装虚拟化软件，然后再安装虚拟系统。过程稍嫌繁琐。对技术菜鸟也有难度。<br />&#12288;&#12288;缺点2：对系统的硬件有一定的要求（如果你的电脑硬件太寒酸，就别考虑这招了）。<br /><br /><h2>★“动态 User Agent”方案</h2><br />&#12288;&#12288;善于思考的同学会发现：前面三个招数，其本质是相通滴。说白了都是利用技术手段“隔离”出不同的浏览器环境，然后单独修改每个环境的指纹，以此来伪造出多个身份。但是对于每一个具体的环境，其指纹依然是固定的。换句话说，前面那三个招数都是针对“唯一性”。下面俺要介绍的招数可以用来破坏“稳定性”。<br />&#12288;&#12288;前面说了，浏览器指纹的信息量，至少有一半以上是来自于 User Agent。所以要破坏浏览器指纹的稳定性，只要让浏览器的 User Agent 动态变化即可。下面分别说明技术思路（以下的招数适合于有一定折腾能力的同学，需要用到一点编写脚本的伎俩）。<br /><br /><h3>◇如何构造随机的 User Agent</h3><br />&#12288;&#12288;要构造随机的 User Agent ，其实也不难。到“<a href="http://www.useragentstring.com/pages/useragentstring.php" target="_blank" rel="nofollow">这个网站</a>”可以看到各种各样浏览器的 User Agent。你可以收集一大堆预存着，然后每次从中随机挑选一条作为你的伪装。为了做到每次随机挑选并设置，你可以写一个脚本来干这事儿，然后顺便让这个脚本来帮你启动浏览器。<br />&#12288;&#12288;再唠叨一下：挑选 User Agent 是有讲究滴，要尽量选择那些比较常见的 User Agent――越常见的 User Agent 所包含的信息量越小。<br /><br /><h3>◇Firefox</h3><br />&#12288;&#12288;三大浏览器中，最有利于隐私保护的是 Firefox（具体的原因分析请看本系列<a href="../../2013/06/privacy-protection-2.md">前面的博文</a>），所以先说它的技术实现。<br />&#12288;&#12288;对于默认安装的 Firefox，在 <b>%APPDATA%\Mozilla\Firefox\Profiles</b> 目录下可以看到 Firefox 【<b>默认实例</b>】的目录（目录名类似于“xxxxxxxx.default”）。进入该目录会看到一个 user.js 的文件（如果没有的话就自己新建一个）。<br />&#12288;&#12288;俺之前介绍过，想要伪造一个【<b>静态</b>】的 User Agent，只需修改 user.js，往里面添加如下代码。代码中的 xxx 就是要伪造的 User Agent。<br /><blockquote style="background-color:#DDD;">user_pref("general.useragent.override", "xxx");</blockquote>&#12288;&#12288;至于要伪造【<b>动态</b>】的 User Agent，只需用脚本来自动修改 user.js 文件里面的这行代码，生成一个随机的 User Agent。修改完再用这个脚本把 Firefox 启动起来。<br />&#12288;&#12288;对于 Windows 下的 Firefox，可以用 VBScript 或 JScript 或 PowerShell 这三种系统内置的脚本；对于 Linux 或苹果系统，可以尝试各种 shell 脚本。<br />&#12288;&#12288;某些爱思考的同学可能会问，为啥不直接在 user.js 里面用 javascript 代码进行 User Agent 的随机设定。俺曾经也企图这么干，好像不行 :( 不信你自己试试看。<br /><br /><h3>◇Chrome</h3><br />&#12288;&#12288;对于 Chrome，可以在命令行参数指定其 User Agent，具体请参见“<a href="../../2013/07/privacy-protection-4.html#user_agent">这篇博文</a>”。<br />&#12288;&#12288;所以，你只需在脚本中启动 Chrome，每次都传递一个随机的 User Agent 作为命令行参数。<br />&#12288;&#12288;对于 Windows 下的 Chrome，可以用 VBScript 或 JScript 或 PowerShell 这三种系统内置的脚本；对于 Linux 或苹果系统，可以尝试各种 shell 脚本。<br /><br /><h3>◇IE</h3><br />&#12288;&#12288;对于 IE 的 User Agent，需要修改注册表的键值（<b>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\User Agent</b>）。所以捏，可以通过事先写好的脚本（VBScript 或 JScript 或 PowerShell）往相应的注册表键值中写入随机的User Agent，然后再由这个脚本启动 IE。<br /><br /><h2>★后记</h2><br />&#12288;&#12288;补充说明几点：<br /><br /><h3>◇对于“动态 UserAgent 方案”，为啥不直接给出代码</h3><br />&#12288;&#12288;估计肯定有人会抱怨这个。提醒一下：【<b>授人以鱼不如授人以渔</b>】是本博客长期奉行的原则。所以在技术方面，俺更愿意分享一些思路，尽量避免直接给出现成的东西。自己动手实践，有助于能力的提升而且印象更深刻。<br />&#12288;&#12288;如果你是个程序猿/程序媛，写这样一个脚本应该是易如反掌滴；如果你不是搞技术的，顺便学一下简易的脚本编程（其实很容易滴）。不会编程的同学，俺建议从 Python 开始入手，功能强且门槛低，具体请参见《<a href="../../2009/08/why-choose-python-0-overview.md">为啥俺推荐 Python</a>》系列博文。<br /><br /><h3>◇关于“虚拟系统的屏幕分辨率”</h3><br />&#12288;&#12288;如果你使用“操作系统虚拟机”，需要留意“屏幕分辨率的问题”。<br />&#12288;&#12288;对于【不】使用虚拟机的普通网友，其屏幕分辨率也就是常见的那几种（大概在20种以内）。但如果你在 Guest OS 里面上网，并且你【没有】使用全屏模式，那么 Guest OS 的分辨率可能会是一个很奇怪的分辨率（因为独特性很高，所以带有很多的“指纹信息量”）。<br />&#12288;&#12288;所以，俺建议那些用虚拟系统上网的同学，始终采用“全屏模式”。<br /><br /><h3>◇关于“HTML5 的 Canvas 指纹”</h3><br />&#12288;&#12288;在本文发布约半年后，有读者在博客留言中询问了“基于 HTML5 的 Canvas 语法进行指纹追踪”。所以俺单独补充了这一小节。<br />&#12288;&#12288;所谓的“HTML5 的 Canvas 指纹”，依赖的是 HTML5 新增的 Canvas 语法。利用这个 Canvas 语法可以实现一些绘图的功能。由于不同类型的浏览器使用了不同的绘图引擎，所以这可以成为某种指纹信息。<br />&#12288;&#12288;一般情况下，如果你禁用了 JS 脚本，可以让“Canvas 指纹”失效。所以你可以用一些安全扩展（比如 NoScript），对你不信任的网站禁用 JS 脚本。另外，电子前哨基金会（EFF）提供的 Privacy Badger 扩展，可以屏蔽“Canvas 指纹”。<br />&#12288;&#12288;要测试自己的浏览器是否存在“Canvas 指纹”，请猛击“<a href="https://www.browserleaks.com/canvas" target="_blank" rel="nofollow">这个链接</a>”。<br />&#12288;&#12288;退一步讲，就算你无法屏蔽“Canvas 指纹”，也不用怕。在本文开头提到了“防范指纹的一般性原则？”。其中之一是“破坏唯一性”。你可以用本文介绍的几个招数来破坏唯一性。提醒一下：单纯用“多实例”的招数无法破坏“Canvas 指纹”的唯一性。因为在“多实例”的情况下，每个实例共享同一个浏览器引擎。所以你必须采用“多浏览器”或者“多虚拟机”的方式。<br /><br /><h3>◇关于 EFF 的浏览器指纹测试</h3><br />&#12288;&#12288;<a href="../../2014/01/privacy-protection-5.md">前一篇博文</a>介绍了 EFF 的浏览器指纹测试工具，估计很多同学都去测试了。其实捏，不必太在意具体每一项的“比特数”。大伙儿只需要关注其“定性”而不必太在意其“定量”。因为 EFF 网站目前收集的样本还不够多（只有几百万），所以其分析出的信息量（相比全球的统计数据）会有所偏差。<br />&#12288;&#12288;另外，很多人测试下来的总信息量是 21.85 bits，这是因为 EFF 的总样本目前只有 370万 左右（370万 约等于 2的21.85次方）。所以比特数到 21.85 就封顶了。<br /><br /><a href="../../2013/06/privacy-protection-0.html#index">回到本系列的目录</a><div class="blogger-post-footer">
</div>
<hr>
<div class="copyright">
<h4>版权声明</h4>
本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者<a href="mailto:program.think@gmail.com">编程随想</a>和本文原始网址：<br>
<a href="/2014/01/privacy-protection-6.md">2014/01/privacy-protection-6.html</a>
</div>
</div>
</body>
</html>
